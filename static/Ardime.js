!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Ardime=e():t.Ardime=e()}(self,(()=>(()=>{"use strict";var t={d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{Camera2D:()=>A,Const:()=>U,Geometry:()=>I,Image:()=>E,Performance:()=>L,Renderer:()=>S,UniformContainer:()=>f,useLibrary:()=>B});var r={};t.r(r),t.d(r,{applyTransformation:()=>D,newTransformation:()=>w,rotateX:()=>y,rotateY:()=>v,rotateZ:()=>C,translate:()=>R});const i={Integer:0,Float:1,Vector2:2,Vector3:3,Vector4:4,Matrix4:5,IntegerArray:6};let s={WebGL:null};const a={Millisec:0,Seconds:1,Minutes:2,Hours:3},n={math:null},o={UniformTypes:i,RenderingContext:s,Time:a};function h(t,e){const r={...t};if(null==e)return r;for(const i in r)if(typeof e[i]==typeof t[i]||null==t[i])if("object"==typeof e[i]&&null!=t[i])for(const t in e[i])null!=r[i][t]&&(r[i][t]=e[i][t]);else r[i]=e[i];return r}let m=0;class c{constructor(t,e,r,i){this.id=m,++m,this.m_indexBuffer=null,this.m_vertexArray=null,this.m_attributeDetails=new Map,this.m_uniformContainers=[],this.m_program=function(t,e){const r=s.WebGL,i=u(t,r.VERTEX_SHADER),a=u(e,r.FRAGMENT_SHADER),n=r.createProgram();return r.attachShader(n,i),r.attachShader(n,a),r.linkProgram(n),r.getProgramParameter(n,r.LINK_STATUS)||console.error(`ERROR linking program! ${r.getProgramInfoLog(n)}`),r.validateProgram(n),r.getProgramParameter(n,r.VALIDATE_STATUS)||console.error(`ERROR validating program! ${r.getProgramInfoLog(n)}`),n}(t,e),this.bind(),this.$setupAttributes(r),i&&this.$setupUniforms(i),this.$setupIndexBuffer()}getAttributesList(){const t=new Array(this.m_attributeDetails.size);let e=0;for(const r of this.m_attributeDetails.keys()){const i=this.m_attributeDetails.get(r);t[e]={name:r,size:i.size,offset:i.offset},++e}return t}bind(){const t=s.WebGL;t.useProgram(this.m_program),t.bindVertexArray(this.m_vertexArray)}setAttributeData(t,e){const r=s.WebGL;if(this.m_attributeDetails.has(t)){this.bind();const i=this.m_attributeDetails.get(t).bufferObject;r.bindBuffer(r.ARRAY_BUFFER,i),r.bufferData(r.ARRAY_BUFFER,e,r.DYNAMIC_DRAW)}else console.error(`[ERROR] Attribute "${t}" Cannot Be Found!`)}setAllAttributes(t){for(const e of t.getAttribList())this.setAttributeData(e,t)}updateUniforms(){for(const t of this.m_uniformContainers)t.uniform.isUpdated(this.id)||this.$setUniformData(t)}uniformIsUpdated(){for(const t of this.m_uniformContainers)if(!t.uniform.isUpdated(this.id))return!1;return!0}setIndicesData(t){const e=s.WebGL;this.bind(),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.m_indexBuffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array(t),e.DYNAMIC_DRAW)}$setUniformData(t){const e=s.WebGL,r=t.uniform.getData(),a=t.location;switch(t.uniform.getType()){case i.Integer:e.uniform1i(a,r);break;case i.Float:e.uniform1f(a,r);break;case i.Vector2:e.uniform2f(a,r[0],r[1]);break;case i.Vector3:e.uniform3f(a,r[0],r[1],r[2]);break;case i.Vector4:e.uniform4f(a,r[0],r[1],r[2],r[3]);break;case i.Matrix4:e.uniformMatrix4fv(a,e.FALSE,new Float32Array(r.flat()));break;case i.IntegerArray:e.uniform1iv(a,r)}}$setupIndexBuffer(){const t=s.WebGL;this.m_indexBuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.m_indexBuffer)}$setupAttributes(t){const e=s.WebGL;this.m_vertexArray=e.createVertexArray(),e.bindVertexArray(this.m_vertexArray);let r=0;for(const e of t)r+=e.size;let i=0;for(const s of t){const t=e.createBuffer();e.bindBuffer(e.ARRAY_BUFFER,t);const a=e.getAttribLocation(this.m_program,s.name);this.m_attributeDetails.set(s.name,{size:s.size,bufferObject:t,offset:i}),e.vertexAttribPointer(a,s.size,e.FLOAT,e.FALSE,r*Float32Array.BYTES_PER_ELEMENT,i*Float32Array.BYTES_PER_ELEMENT),e.enableVertexAttribArray(a),i+=s.size}}$setupUniforms(t){const e=s.WebGL;for(const r of t){const t=e.getUniformLocation(this.m_program,r.name);r.value.connect(this),this.m_uniformContainers.push({location:t,uniform:r.value})}}}function u(t,e){const r=s.WebGL,i=r.createShader(e);return r.shaderSource(i,t),r.compileShader(i),r.getShaderParameter(i,r.COMPILE_STATUS)||console.error(`ERROR compiling shader! ${r.getShaderInfoLog(i)}`),i}class l{constructor(){}setup(t){const e=t.getContext("webgl2",{preserveDrawingBuffer:!0});return s.WebGL=e,!!e&&(e.enable(e.DEPTH_TEST),e.depthFunc(e.LEQUAL),e.enable(e.BLEND),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT|e.STENCIL_BUFFER_BIT),!0)}render(t,e){const r=s.WebGL;t.setAllAttributes(e.getAllAttributes()),t.setIndicesData(e.getIndicesBuffer()),t.bind(),r.drawElements(r.TRIANGLES,e.getIndicesBuffer().getCount(),r.UNSIGNED_SHORT,0)}clear(t){s.WebGL.clear(t)}getDepthBufferBit(){return s.WebGL.DEPTH_BUFFER_BIT}getColorBufferBit(){return s.WebGL.COLOR_BUFFER_BIT}getStencilBufferBit(){return s.WebGL.STENCIL_BUFFER_BIT}}const _={vertex:"precision mediump float;\n\nattribute vec2 a_position;\nattribute vec4 a_color;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_projection;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main()\n{\n\tgl_Position = u_projection * vec4(a_position, 0.0, 1.0);\n\tv_color = a_color;\n\tv_texCoord = a_texCoord;\n}\n",fragment:"precision mediump float;\n\nuniform sampler2D u_texture;\n\nvarying vec4 v_color;\nvarying vec2 v_texCoord;\n\nvoid main() {\n\tgl_FragColor = texture2D(u_texture, v_texCoord) * (v_color / vec4(255));\n}\n"},f=class{constructor(t,e){this.m_uniformType=t,this.m_shaders=new Map,this.m_data=e}connect(t){this.m_shaders.has(t.id)||this.m_shaders.set(t.id,!1)}set(t){this.m_data=t;for(const t of this.m_shaders.keys())this.m_shaders.set(t,!1)}getType(){return this.m_uniformType}getData(){return this.m_data}uniformUpdated(t){this.m_shaders.set(t,!0)}isUpdated(t){return this.m_shaders.get(t)}};class d{constructor(t,e){this.m_indexBuffer=new g(e),this.m_attributesArr=new p(t)}empty(){return 0==this.m_indexBuffer.getCount()}setShader(t){t.bind();const e=t.getAttributesList();this.m_attributesArr.clear(),this.m_attributesArr.resetAttribDetails();for(const t of e)this.m_attributesArr.setAttribDetails(t.name,t.offset,t.size)}clear(){this.m_attributesArr.clear(),this.m_indexBuffer.clear()}appendShape(t){if(!this.m_indexBuffer.validateSize(t.length))return!1;if(!this.m_attributesArr.validateSize(t.length))return!1;for(const e of t)if(!this.m_attributesArr.insert(e))throw new Error("Invalid data");let e=0;const r=new Uint16Array(3*t.length-6);for(let i=2;i<t.length;i++)r[e]=0,r[e+1]=i-1,r[e+2]=i,e+=3;return this.m_indexBuffer.insert(r,t.length),!0}getAllAttributes(){return this.m_attributesArr}getIndicesBuffer(){return this.m_indexBuffer}}class g extends Uint16Array{constructor(t){super(t),this.m_counter=0,this.m_totalVertexCount=0}clear(){this.m_counter=0,this.m_totalVertexCount=0}insert(t,e){if(this.m_counter+t.length>super.length)return!1;const r=[...t];for(const t in r)r[t]=r[t]+this.m_totalVertexCount;return super.set(r,this.m_counter),this.m_counter+=t.length,this.m_totalVertexCount+=e,!0}validateSize(t){const e=3*t-6,r=this.m_totalVertexCount+t;return this.m_counter+e<=super.length&&r<65535}getCount(){return this.m_counter}}class p extends Float32Array{constructor(t){super(t),this.m_contentSize=0,this.m_attribDetails=new Map,this.m_vertexLength=0}clear(){this.m_contentSize=0}resetAttribDetails(){this.m_vertexLength=0,this.m_attribDetails.clear()}setAttribDetails(t,e,r){this.m_attribDetails.set(t,{offset:e,size:r}),this.m_vertexLength+=r}insert(t){for(const e of this.m_attribDetails.keys())if(null==t[e])return!1;for(const e of this.m_attribDetails.keys()){const r=this.m_attribDetails.get(e);super.set(t[e],this.m_contentSize+r.offset)}return this.m_contentSize+=this.m_vertexLength,!0}validateSize(t){return this.m_contentSize+t*this.m_vertexLength<super.length}getAttribDetail(t){return this.m_attribDetails.get(t)}getAttribList(){return this.m_attribDetails.keys()}}function b(t){return[[Math.cos(t),Math.sin(t),0,0],[-Math.sin(t),Math.cos(t),0,0],[0,0,1,0],[0,0,0,1]]}function x(t,e,r){return[[1,0,0,0],[0,1,0,0],[0,0,1,0],[t,e,r,1]]}const A=class{constructor(...t){this.m_camera={x:0,y:0,width:1,height:1,rotation:0,near:0,far:-1},this.m_baseProjection=null,2==t.length?(this.m_camera.width=t[0],this.m_camera.height=t[1]):4==t.length?(this.m_camera.x=t[0],this.m_camera.y=t[1],this.m_camera.width=t[2],this.m_camera.height=t[3]):5==t.length&&(this.m_camera.x=t[0],this.m_camera.y=t[1],this.m_camera.width=t[2],this.m_camera.height=t[3],this.m_camera.far=t[4]),this.m_uniformContainer=new f(i.Matrix4,null),this.m_cameraMatrix=null,this.createMatrix()}setBaseProjection(t){this.m_baseProjection=t}getUniformContainer(){return this.m_uniformContainer}createMatrix(){const t=this.m_camera.x,e=this.m_camera.y,r=this.m_camera.width,i=this.m_camera.height,s=this.m_camera.near;let a=[[2/((h=r/2)-(o=-r/2)),0,0,0],[0,2/((m=-i/2)-(c=i/2)),0,0],[0,0,-2/((l=this.m_camera.far)-(u=s)),0],[-(h+o)/(h-o),-(m+c)/(m-c),-(l+u)/(l-u),1]];var o,h,m,c,u,l;null!=this.m_baseProjection&&(a=n.math.multiply(this.m_baseProjection,a));const _=b(-this.m_camera.rotation),f=x(-t,-e,0);this.m_cameraMatrix=n.math.multiply(f,_),this.m_cameraMatrix=n.math.multiply(this.m_cameraMatrix,a),this.m_uniformContainer.set(this.m_cameraMatrix)}move(t,e){this.m_camera.x+=t,this.m_camera.y+=e}setPosition(t,e){this.m_camera.x=t,this.m_camera.y=e}setNearFar(t,e){this.m_camera.near=t,this.m_camera.far=e}resize(t,e){this.m_camera.width=t,this.m_camera.height=e}setAngle(t){this.m_camera.rotation=t}rotateAngle(t){this.m_camera.rotation+=t}getPosition(){return{x:this.m_camera.x,y:this.m_camera.y}}getSize(){return{width:this.m_camera.width,height:this.m_camera.height}}getX(){return this.m_camera.x}getY(){return this.m_camera.y}getWidth(){return this.m_camera.width}getHeight(){return this.m_camera.height}getNear(){return this.m_camera.near}getFar(){return this.m_camera.far}getAngle(){return this.m_camera.rotation}getMatrix(){return this.m_cameraMatrix}};let T=1;const E=class{constructor(t,e,r){if(this.m_texture=null,this.properties=function(t){return t?h({smooth:!0},t):null}(e),this.id=T++,"string"==typeof t){const e=new Image;e.onload=()=>{this.properties.width=e.width,this.properties.height=e.height;const t=function(t){const e=document.createElement("canvas");e.width=t.width,e.height=t.height;const r=e.getContext("2d");return r.scale(1,-1),r.drawImage(t,0,-e.height),e}(e);this.$createWebGLTexture(t),"function"==typeof r&&r()},e.src=t,e.setAttribute("crossOrigin","")}else if(t instanceof Uint8Array){this.properties.width=e.width,this.properties.height=e.height;const r=4,i=t.length/r;if("number"!=typeof this.properties.width||"number"!=typeof this.properties.height)throw new Error("[ERROR] Texture missing a width and height property!");if(this.properties.width*this.properties.height!=i)throw new RangeError("[ERROR] Cannot create texture due to an invalid number of pixels!");this.$createWebGLTexture(t)}}bind(t){const e=s.WebGL;e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,this.m_texture)}$createWebGLTexture(t){const e=s.WebGL;this.m_texture=e.createTexture(),this.bind(0),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,this.properties.width,this.properties.height,0,e.RGBA,e.UNSIGNED_BYTE,t);const r=this.properties.smooth?e.LINEAR:e.NEAREST;e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.REPEAT),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,r)}};function w(){return[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]}function R(t,e,r,i){const s=x(e,r,i);return n.math.multiply(t,s)}function y(t,e){const r=(i=e,[1,0,0,0,0,Math.cos(i),Math.sin(i),0,0,-Math.sin(i),Math.cos(i),0,0,0,0,1]);var i;return n.math.multiply(t,r)}function v(t,e){const r=(i=e,[Math.cos(i),0,-Math.sin(i),0,0,1,0,0,Math.sin(i),0,Math.cos(i),0,0,0,0,1]);var i;return n.math.multiply(t,r)}function C(t,e){const r=b(e);return n.math.multiply(t,r)}function D(t,e){return n.math.multiply([...e,1],t).flat()}class S{constructor(t){this.m_shader=null,this.m_defaultShader=null,this.m_defaultCamera=new A,this.m_whiteImage=null,this.settings=function(t){if("object"!=typeof t)return{error:!0,message:"[ERROR] Renderer settings must be a JSON Object!"};let e=h({canvas:null,width:100,height:100},t);return null==e.canvas?{error:!0,message:"[ERROR] Renderer settings is missing canvas id!"}:(e.canvas=document.getElementById(e.canvas),e)}(t),this.m_webgl=new l,this.m_webgl.setup(this.settings.canvas)||console.error("webgl not supported!"),this.$setupCamera(0,0,this.settings.canvas.width,this.settings.canvas.height),this.$createShaders(),this.$createDefaultImage(),this.m_verticesContainer=new d(5e4,1e4),this.m_verticesContainer.setShader(this.m_defaultShader),this.m_shader=this.m_defaultShader,this.webgl=s.WebGL,this.maxTextureSlots=this.webgl.getParameter(this.webgl.MAX_TEXTURE_IMAGE_UNITS),this.m_textureTracker=new Uint8Array(this.maxTextureSlots),this.m_defaultDrawingOptions=void 0,this.$createDefaultDrawingOptions(),this.draw={rect:(t,e,r,i,s)=>{this.drawImage(this.m_whiteImage,t,e,r,i,s)},image:(t,e,r,i,s,a)=>{this.drawImage(t,e,r,i,s,a)},shape:{new:()=>this.newShape(),vertex:(t,e,r)=>{this.createVertex(t,e,r)},draw:(t,e)=>{this.drawShape(t,e)}},bind:{texture:(t,e)=>{this.bindTexture(t,e)}}},this.create={shader:(t,e,r,i)=>this.createShader(t,e,r,i),uniformContainer:(t,e)=>new f(t,e)}}clear(t){let e=this.m_webgl.getColorBufferBit();"object"==typeof t&&(1==t.depth&&(e|=this.m_webgl.getDepthBufferBit()),1==t.stencil&&(e|=this.m_webgl.getStencilBufferBit())),this.m_webgl.clear(e)}createShader(t,e,r,i){const s=new c(t,e,r,i);return this.m_shader=s,this.m_verticesContainer.setShader(s),s}setDefaultOption(t){this.m_defaultDrawingOptions=h(this.m_defaultDrawingOptions,t)}drawImage(t,e,r,i,s,a){const n=h(this.m_defaultDrawingOptions,a);this.bindTexture(t,0);const o=n.align.split(" ");let m={x:e,y:r};switch(o[0]){case"center":m.y-=s/2;break;case"bottom":m.y-=s}switch(o[1]){case"center":m.x-=i/2;break;case"right":m.x+=i}let c=[[m.x,m.y,0],[m.x+i,m.y,0],[m.x+i,m.y+s,0],[m.x,m.y+s,0]];if(0!=n.angle){let t=[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]];t=R(t,-e,-r,0),t=C(t,n.angle),t=R(t,e,r,0);for(let e=0;e<c.length;++e)c[e]=D(t,c[e])}const u=this.newShape();this.createVertex(u,{position:[c[0][0],c[0][1]],color:n.color,texCoord:[0,1]}),this.createVertex(u,{position:[c[1][0],c[1][1]],color:n.color,texCoord:[1,1]}),this.createVertex(u,{position:[c[2][0],c[2][1]],color:n.color,texCoord:[1,0]}),this.createVertex(u,{position:[c[3][0],c[3][1]],color:n.color,texCoord:[0,0]}),this.drawShape(u)}bindTexture(t,e){this.m_textureTracker[e]!=t.id&&(this.$makeDrawCall(),t.bind(e),this.m_textureTracker[e]=t.id)}newShape(){return[]}createVertex(t,e,r){if(r)return void t.push(e);const i=h({position:[0,0],color:[255,255,255,255],texCoord:[0,0]},e);t.push({a_position:i.position,a_color:i.color,a_texCoord:i.texCoord})}getCamera(){return this.m_defaultCamera}drawShape(t,e){null==e&&(e=this.m_defaultShader),e.id!=this.m_shader.id&&(this.$makeDrawCall(),this.m_verticesContainer.setShader(e),this.m_shader=e),e.uniformIsUpdated()||(this.$makeDrawCall(),e.updateUniforms()),this.m_verticesContainer.appendShape(t)||(this.$makeDrawCall(),this.m_verticesContainer.appendShape(t))}flush(){this.$makeDrawCall()}$makeDrawCall(){this.m_verticesContainer.empty()||(this.m_webgl.render(this.m_shader,this.m_verticesContainer),this.m_verticesContainer.clear())}$createShaders(){const t=new f(i.Integer,0);this.m_defaultShader=new c(_.vertex,_.fragment,[{name:"a_position",size:2},{name:"a_color",size:4},{name:"a_texCoord",size:2}],[{name:"u_projection",value:this.m_defaultCamera.getUniformContainer()},{name:"u_texture",value:t}])}$createDefaultImage(){const t=new Uint8Array([255,255,255,255]);this.m_whiteImage=new E(t,{width:1,height:1}),this.m_whiteImage.bind(0)}$createDefaultDrawingOptions(){this.m_defaultDrawingOptions={align:"top left",color:[255,255,255,255],angle:0}}$setupCamera(t,e,r,i){this.m_defaultCamera.setPosition(t,e),this.m_defaultCamera.resize(r,i),this.m_defaultCamera.createMatrix()}}const L=class{constructor(){this.m_startTime=(new Date).getTime(),this.m_elapsedTime=void 0}start(){this.m_startTime=(new Date).getTime()}stop(){return this.m_elapsedTime=(new Date).getTime()-this.m_startTime,this.m_elapsedTime}getElapsedTime(t){switch(t){case a.Millisec:return this.m_elapsedTime;case a.Seconds:return this.m_elapsedTime/1e3;case a.Minutes:return this.m_elapsedTime/6e4;case a.Hours:return this.m_elapsedTime/36e5;default:return this.m_elapsedTime}}};function B(t,e){"mathjs"===t&&(n.math=e)}const I={Transformation:r},U=o;return e})()));